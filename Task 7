# Урок 8 - Декораторы и модули
## Контрольные вопросы:
- Что делает команда __from module import *__? Какие проблемы могут возникнуть при её использовании?

Команда from module import * импортирует все имена из модуля в текущее пространство имен. Проблемы могут возникнуть из-за возможных конфликтов имен, затрудняющих отслеживание источника импортированных объектов.

- Какое определение функции будет использовано при возникновении конфликта имен?

При возникновении конфликта имен будет использовано определение функции из последнего импортированного модуля.

- Зачем нужен \__init__.py? Каким должно быть его содержимое?

 _init_.py нужен для того, чтобы Python рассматривал каталог, в котором он находится, как пакет. Содержимое _init_.py может быть пустым, но также может содержать код, который будет выполнен при импортировании пакета.

- В чем проблемы использования декораторов? Можно ли процесс декорирования обернуть вспять?

Проблемы при использовании декораторов могут возникнуть из-за сложности отслеживания порядка применения декораторов. Процесс декорирования можно отменить, но это может потребовать изменения исходного кода. Гипотетически можно, но не оправдывает усилий.

- Как порядок декорирования влияет на результат работы функции?

Порядок декорирования влияет на результат работы функции, так как каждый декоратор может изменить поведение функции. Если функция декорирована несколькими декораторами, то порядок их применения может быть критически важным. Например, если один декоратор изменяет аргументы функции, а другой изменяет возвращаемое значение, то результат работы функции будет зависеть от порядка применения декораторов.

- В каких случаях имеет смысл использовать декораторы?

1. Для добавления дополнительной функциональности к существующей функции без изменения ее исходного кода.
2. Для повторного использования общей функциональности, такой как логирование, проверка прав доступа, кэширование и т.д.
3. Для разделения основной логики функции от дополнительной функциональности, что делает код более читаемым.
4. Для применения одной и той же функциональности к нескольким функциям без дублирования кода.
5. Для изменения поведения функции в зависимости от контекста.

## Задания:
1) Написать декоратор, разворачивающий порядок 
переданных в функцию аргументов независимо от их 
количества (например декорированная `foo(4, 5)` должна
быть эквивалентна вызову недекорированной `foo(5, 4)`).
2) Написать декоратор, печатающий аргументы, 
переданные функции, после её выполнения.
3) Написать декоратор, пробующий запустить 
переданную функцию, и возвращающий строку __"error"__ в 
случае возникновения исключения.
4) Написать программу, сравнивающую скорость работы 
функции вычисления чисел Фибоначчи, написанной через 
циклы и через рекурсию, с использованием `@cache`
и без.
