## Контрольные вопросы:
- В чем основная идея полиморфизма?
__Полиморфизм__ - множественная реализация, единый интерфейс.
Основная идея полиморфизма состоит в возможности использования объектов разных классов с одинаковым интерфейсом без необходимости знать их конкретный тип.

- Как называется типизация в Python и какой идеей она руководствуется?
Типизация в Python называется динамической, так как тип переменной определяется во время выполнения программы, а не на этапе компиляции.

__Утиная типизация__ – это концепция, характерная для языков программирования с динамической типизацией, согласно которой конкретный тип или класс объекта не важен, а важны лишь свойства и методы, которыми этот объект обладает. Т.е. при работе с объектом его тип не проверяется, вместо этого проверяются свойства и методы этого объекта.

Если это выглядит как утка, плавает как утка и крякает как утка, то это, вероятно, и есть утка.
 
- Что такое перегрузка функций? Чем мы её заменяем в Python?

Перегрузка функций - это возможность определить несколько функций с одним и тем же именем, но с разными параметрами. Например мы определяем функцию сложения для нескольких разных типов данных, отдельно для каждого, но при этом в интерфейсе пользуемся одним и тем же названием функции. В Python перегрузка функций не поддерживается напрямую, но можем использовать магические методы.

__Примеры:__
```
__add__(self, other) # сложение. x + y вызывает x.__add__(y).
__sub__(self, other) # вычитание (x - y).
__mul__(self, other) # умножение (x * y).
__truediv__(self, other) # деление (x / y).
__iadd__(self, other) # +=.
__isub__(self, other) # -=ю
__abs__(self) # модуль (abs()).
```

-Каким образом можно проверить переменную на принадлежность к группе типов / классов?

Для проверки переменной на принадлежность к группе типов или классов в Python можно использовать функцию isinstance(). Она принимает два аргумента: переменную, которую нужно проверить, и тип или класс, к которому нужно проверить принадлежность. Функция возвращает True, если переменная принадлежит указанному типу или классу, и False в противном случае.

__isinstance(object, classinfo)__

Возвращает True, если аргумент объекта является экземпляром аргумента classinfo или его подкласса. Если объект не является объектом данного типа, функция всегда возвращает False. Если classinfo является кортежем объектов типа, то функция возвращает True, в том случае если объект является экземпляром любого из типов. Если classinfo не является типом или кортежем типов, возникает исключение TypeError. TypeError не может быть вызван для недопустимого типа, если более ранняя проверка прошла успешно.

Цитата и кривой перевод из документации к Python.

- Каким образом мы реализуем полиморфизм для созданных нами объектов?

Для реализации полиморфизма для созданных нами объектов необходимо определить общий интерфейс (набор методов), который будет использоваться для работы с этими объектами. Все объекты должны иметь эти методы, но могут реализовывать их по-разному. Это позволяет использовать эти объекты вместе, вызывая одни и те же методы, но получая разные результаты в зависимости от конкретной реализации каждого объекта.

Пример:

```
    def __add__(self, other):
        if isinstance(other, Pair):
            return Pair(self.get_x() + other.get_x(), self.get_y() + other.get_y())
        elif isinstance(other, (int, float)):
            return Pair(self.get_x() + other, self.get_y() + other)
```

 - Зачем переопределять метод __radd__() наравне с __add__()?

Метод __radd__() переопределяется вместе с методом __add__() для поддержки коммутативности сложения. Если объект не поддерживает операцию сложения с объектом другого типа, то Python пытается вызвать метод __radd__() у объекта другого типа и передать текущий объект в качестве аргумента. Это позволяет обработать случай, когда объект находится справа от оператора сложения и не поддерживает операцию сложения с объектом текущего типа.
