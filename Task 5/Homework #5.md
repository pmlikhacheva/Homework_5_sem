## Контрольные вопросы

- На что ориентируется цикл for для завершения итерации?

Цикл for завершает итерацию, когда у итерируемого объекта, по которому происходит итерация, больше нет элементов для обработки.

- Какие функции / методы используются для работы с итерируемыеми объектами и с итераторами?

Для работы с итерируемыми объектами используются методы __next__() и __iter__().

iterator.__iter__()¶
Возвращает сам объект итератора. Это необходимо для того, чтобы позволить использовать как контейнеры, так и итераторы с утверждениями for и in.
iterator.__next__()¶
Возвращает следующий элемент из итератора. Если больше нет элементов, то будет вызвано исключение StopIteration.
 
- Должен ли объект быть упорядоченным, чтобы быть итерируемым?

Объект не обязательно должен быть упорядоченным, чтобы быть итерируемым. Для него просто должен работать метод __iter__(), который возвращает итератор.

- Какая разница между созданием нового класса для итератора и подходом, когда объект сам является своим итератором?

При создании нового класса для итератора мы определяем методы __iter__() и __next__(), которые позволяют нам управлять итерацией. Когда объект сам является своим итератором, он должен реализовывать только метод __next__().

- В чем отличия генератора от итератора?

Генератор - это специальный тип функции, который возвращает итератор. Он использует ключевое слово yield для возврата значений по мере необходимости. Итератор - это объект, который может быть проитерирован (перебран) с помощью цикла for или функции next().

- Какое ключевое слово позволяет нам создать функцию-генератор?

Ключевое слово yield позволяет создать функцию-генератор.

- Какую роль играет ключевое слово return внутри функции-генератора? Объект, указанный справа от return?

return внутри функции-генератора играет роль завершения генерации значений и прекращения итерации. Объект, указанный справа от return, будет возвращен в качестве последнего значения генератора.

## Задания:

1. В процессе
2. Fib.py
3. my_range.py
